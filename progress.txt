# Mocha Development Progress

## 2026-01-12 - setup-webui COMPLETED

### What was done:
- Downloaded WebUI library v2.5.0-beta.3 for macOS ARM64
- Created lib/ directory with webui.h, webui.hpp, and libwebui-2-static.a
- Created src/main.c with full implementation of all 3 bindings:
  - readFile(path, offset) - reads file with differential support for polling
  - getRecentFiles() - reads ~/.mocha/recent.json
  - addRecentFile(path) - adds to recent files list
- Created src/Makefile that compiles and links to WebUI static library
- Created dist/index.html test page for verifying bindings
- Successfully compiled mocha binary (264KB ARM64 executable)
- Verified with Playwright that:
  - Binary runs and opens browser window
  - getRecentFiles binding works (returns [])
  - readFile binding works (reads prd.json successfully)

### Files created:
- lib/webui.h, lib/webui.hpp, lib/libwebui-2-static.a
- src/main.c
- src/Makefile
- dist/index.html (test page)
- mocha (compiled binary)

### Notes for next developer:
- The C backend implementation is mostly complete, including JSON escaping
- Multi-client mode is enabled for testing (can be disabled in production)
- Next task should be setup-react to initialize the React/Vite/Tailwind frontend
- The dist/index.html is just a test page - will be replaced by React build output
- Build with: `cd src && make`
- Run with: `./mocha` from project root

## 2026-01-12 - setup-react COMPLETED

### What was done:
- Created ui/ directory with React + TypeScript + Vite project
- Ran `npm create vite@latest . -- --template react-ts`
- Installed tailwindcss and @tailwindcss/vite
- Configured vite.config.ts with:
  - Tailwind plugin
  - Build output to ../dist (so React builds go where WebUI expects them)
- Updated index.css with `@import "tailwindcss"` and monospace font
- Created simple App.tsx with Tailwind-styled "Mocha Log Viewer" test page
- Removed unused boilerplate (App.css, logos)
- Successfully ran `npm run build` - outputs to dist/
- Verified with Playwright that dev server shows styled React app

### Files created:
- ui/package.json
- ui/vite.config.ts
- ui/tsconfig.json, ui/tsconfig.app.json, ui/tsconfig.node.json
- ui/index.html
- ui/src/main.tsx
- ui/src/App.tsx
- ui/src/index.css
- ui/src/vite-env.d.ts
- dist/ (React build output - replaces test index.html)

### Notes for next developer:
- Frontend dev: `cd ui && npm run dev` - runs on http://localhost:5173
- Production build: `cd ui && npm run build` - outputs to ../dist
- Then run `./mocha` to serve the built React app via WebUI
- Next task should be setup-deps to install zustand, lucide-react, murmurhash
- Or could proceed to setup-hello to test WebUI + React integration

## 2026-01-12 - setup-deps COMPLETED

### What was done:
- Installed zustand v5.0.10 for state management
- Installed lucide-react v0.562.0 for icons
- Installed murmurhash v2.0.1 for hash generation
- Updated App.tsx to test all three dependencies:
  - Zustand: Created test store with count/increment, verified state updates
  - Lucide-react: Added FileText, Check, Package icons throughout UI
  - Murmurhash: Computed hash of "test-string" (result: 3758097995)
- Verified with Playwright:
  - All icons render correctly
  - Zustand state management works (increment button updates count)
  - Murmurhash computes and displays hash value
- Build succeeds with all dependencies

### Files modified:
- ui/package.json (added 3 dependencies)
- ui/src/App.tsx (added dependency tests)

### Notes for next developer:
- All setup tasks are now complete (webui, react, deps)
- Next task should be setup-hello to test WebUI + React integration
- The current App.tsx includes test code for dependencies - this can be removed once real components are built
- Zustand pattern: `const useStore = create<State>((set) => ({ ... }))`
- Lucide icons: import as React components from 'lucide-react'
- Murmurhash: use `murmurhash.v3(string)` for consistent hashing

## 2026-01-12 - setup-hello COMPLETED

### What was done:
- Added webui.js script tag to ui/index.html for WebUI bridge communication
- Updated App.tsx with WebUI integration test section that:
  - Detects if running in WebUI context (window.webui exists)
  - Waits for WebSocket connection using webui.isConnected()
  - Tests getRecentFiles binding (returns [] for fresh install)
  - Tests readFile binding (successfully reads prd.json: 22011 bytes)
- Added --headless flag to main.c for testing (uses webui_start_server instead of webui_show)
- Verified with Playwright that:
  - React app loads in WebUI-served browser window
  - WebUI bridge is detected
  - getRecentFiles binding works
  - readFile binding works (read prd.json successfully)
- Captured screenshot of successful test (setup-hello-success.png)

### Files modified:
- ui/index.html (added webui.js script, updated title to "Mocha Log Viewer")
- ui/src/App.tsx (added WebUI Integration Test section)
- src/main.c (added --headless flag support for testing)

### Notes for next developer:
- ALL SETUP TASKS ARE NOW COMPLETE!
- The React frontend now communicates with the C backend via WebUI bindings
- To run normally: `./mocha` (opens browser window)
- To run for testing: `./mocha --headless` (starts server only, outputs URL)
- The App.tsx test UI can be replaced with real log viewer components
- Next tasks should be backend or frontend feature implementations:
  - backend-readfile: Already implemented in setup-webui, may just need verification
  - frontend-types: Create TypeScript type definitions
  - frontend-api: Create WebUI API wrapper (basic version exists in App.tsx)

## 2026-01-12 - frontend-types COMPLETED

### What was done:
- Created ui/src/types.ts with comprehensive TypeScript type definitions
- Defined all core types from spec/log-parser.md:
  - LogEntry, ParsedLogLine, ApiCallInfo, ParsedLogFileResult
  - LogLevel, ApiDirection, ApiPhase (enums/unions)
- Defined file handling types from spec/webui-bindings.md:
  - OpenedFile, RecentFile, FileResult
- Defined filter types:
  - ParsedFilter, FilterType
- Defined Zustand store state interfaces:
  - LogViewerState, SelectionState, FileState
- Defined component props interfaces:
  - SidebarProps, ToolbarProps, LogViewerProps, LogLineProps, DropZoneProps
- Extended Window interface for WebUI global type
- Updated App.tsx to import types (removed duplicate WebUI declaration)
- Verified build succeeds with all types
- Tested with Playwright - WebUI bindings still work correctly

### Files created:
- ui/src/types.ts

### Files modified:
- ui/src/App.tsx (import types instead of declaring WebUI inline)

### Notes for next developer:
- All TypeScript types are now centralized in ui/src/types.ts
- Import types with: `import { LogEntry, FileResult, etc } from './types'`
- The WebUI global type is declared in types.ts, so no need to declare it elsewhere
- Next logical task is frontend-api to create the WebUI API wrapper
- After that, frontend-parser-patterns to implement log parsing

## 2026-01-12 - frontend-api COMPLETED

### What was done:
- Created ui/src/api.ts with clean TypeScript WebUI API wrapper
- Implemented all required functions:
  - isWebUI() - checks if running in WebUI context
  - waitForConnection(timeoutMs) - waits for WebSocket connection
  - readFile(path, offset) - reads file with differential/polling support
  - getRecentFiles() - fetches recent files list from ~/.mocha/recent.json
  - addRecentFile(path) - adds file to recent files list
- All functions properly typed using types from ./types.ts
- Added error handling for all API calls
- Updated App.tsx to use the new API wrapper instead of inline calls
- Verified with Playwright:
  - isWebUI() returns true when served by mocha binary
  - waitForConnection() successfully waits for WebSocket
  - getRecentFiles() returns [] (empty for fresh install)
  - readFile() reads prd.json successfully (22031 bytes)
- Build succeeds

### Files created:
- ui/src/api.ts

### Files modified:
- ui/src/App.tsx (imports and uses API wrapper functions)

### Notes for next developer:
- Import API functions: `import { isWebUI, readFile, getRecentFiles, addRecentFile } from './api'`
- Use waitForConnection() before making API calls if you need to ensure connection is ready
- readFile returns FileResult type with success/error handling built in
- All functions gracefully handle non-WebUI context (return empty/error without crashing)
- Next logical task is frontend-parser-patterns to implement log format parsing

## 2026-01-12 - frontend-parser-patterns, frontend-parser-api, frontend-parser-normalize, frontend-parser-main COMPLETED

### What was done:
- Created ui/src/parser.ts with comprehensive log format parsing
- Implemented all 11 log format patterns from spec:
  1. salesbox-app: SalesBox application format with counter and thread
  2. iwf-spring: IWF/Spring format with source file line numbers
  3. logback-with-source: Full logback with source file info
  4. logback-internal: Logback internal messages (|-INFO format)
  5. maven: Maven build output ([INFO], [ERROR], etc.)
  6. logback: Standard logback format
  7. bracketed: Simple bracketed level format
  8. simple: Timestamp + level + message
  9. logback-time-only: Time-only logback format
  10. level-only: Just [LEVEL] message format
  11. genie-rust: Rust/Genie format with bracketed sections
- Implemented parseApiCall() for API call pattern detection:
  - Outgoing GET/POST/DELETE requests
  - HTTP status responses with timing
  - Incoming request/response patterns
- Implemented continuation line handling:
  - isContinuationLine() detects indented, ASCII art, short lines
  - isTimestampOnlyLine() filters metadata timestamp lines
  - normalize() merges continuation lines with previous entry
- Implemented main parsing functions:
  - parseLogLine() tries each pattern until one matches
  - parseLogFile() handles full file parsing with truncation
  - Handles tab-separated epoch format (metadata timestamps)
  - Limits to last 2000 lines for large files
  - Returns { logs, totalLines, truncated }
- Implemented hash generation using murmurhash for unique log IDs
- Updated App.tsx with parser test UI section
- Verified with Playwright:
  - Genie/Rust format: Full parsing with INFO badges, timestamps, logger names
  - Maven format: Parses ERROR/INFO levels correctly
  - SalesBox format: Cleans up timestamp-only lines properly

### Files created:
- ui/src/parser.ts

### Files modified:
- ui/src/App.tsx (added parser test UI with file upload)
- prd.json (marked 4 parser tasks as complete)

### Notes for next developer:
- Import parser: `import { parseLogFile, parseLogLine, isContinuationLine } from './parser'`
- parseLogFile(content, fileName) returns ParsedLogFileResult with logs array
- Each log has parsed?.level, parsed?.timestamp, parsed?.logger, parsed?.content
- parseApiCall() is called automatically and attaches apiCall info if detected
- The parser handles various edge cases like timestamp-only metadata lines
- Next tasks should be frontend-store-viewer, frontend-store-selection, frontend-store-file for Zustand stores
- Or could proceed to UI components (ui-sidebar, ui-toolbar, ui-logline)

## 2026-01-12 - frontend-store-viewer COMPLETED

### What was done:
- Created ui/src/store.ts with useLogViewerStore Zustand store
- Implemented all required state and actions:
  - inactiveNames: Set<string> for hidden services
  - filters: ParsedFilter[] for text/regex/exclude filters
  - input: string for current filter input
  - toggleName: Solo mode (click to show only that service) or toggle
  - addFilter, removeFilter, clearFilters: Filter management
  - setInput: Input state management
- Added localStorage persistence with custom Set serialization
  - Created setAwareStorage that converts Sets to/from arrays for JSON storage
  - Uses zustand/middleware persist with partialize to exclude input from persistence
- Added helper functions:
  - parseFilterInput(): Parses filter strings into ParsedFilter objects
    - /pattern/ → regex filter
    - -text → exclude filter
    - text → plain text filter
  - filterLogs(): Applies filters and service visibility to log entries
    - Handles include filters (OR logic)
    - Handles exclude filters (AND logic - all must pass)
    - Filters by service name visibility
    - Optional deleted hashes filtering
- Updated App.tsx with Store Test section:
  - Filter input with Enter to submit
  - Active filter chips with remove buttons and color coding
  - Service badge buttons for filtering by service
  - Filtered log count display
  - Integrated filtering with parsed logs display
- Verified with Playwright:
  - Text filter: Added "MCP" filter, reduced logs from 43 to 10
  - Regex filter: Added "/INFO/" filter, displayed as purple chip
  - Exclude filter: Added "-DEBUG" filter, displayed as red chip
  - Remove filter: Clicked X on filter chip, filter removed
  - Clear all: Clicked "Clear all" button, all filters removed
  - Service badge: Displayed for loaded log files

### Files created:
- ui/src/store.ts

### Files modified:
- ui/src/App.tsx (added Store Test section with filter UI)
- prd.json (marked frontend-store-viewer as complete)

### Notes for next developer:
- Import store: `import { useLogViewerStore, parseFilterInput, filterLogs } from './store'`
- Store hook usage: `const { filters, addFilter, toggleName, ... } = useLogViewerStore()`
- Filter parsing: `const filter = parseFilterInput(inputString)` returns ParsedFilter or null
- Filter application: `const filtered = filterLogs(logs, filters, inactiveNames, deletedHashes?)`
- localStorage key: "mocha-log-viewer-state"
- Next tasks should be frontend-store-selection and frontend-store-file for remaining stores
- After stores are complete, proceed to UI components (ui-sidebar, ui-toolbar, ui-logline, ui-logviewer)

## 2026-01-12 - frontend-store-selection COMPLETED

### What was done:
- Added useSelectionStore to ui/src/store.ts with full selection, deletion, and wrap management
- Implemented all required state and actions:
  - selectedHashes: Set<string> for currently selected log hashes
  - deletedHashes: Set<string> for hidden/deleted log hashes
  - wrappedHashes: Set<string> for logs with expanded text wrapping
  - lastSelectedHash: string | null for Shift+Click range selection tracking
  - toggleSelection: Toggle single log selection
  - selectRange: Select range between two hashes (for Shift+Click)
  - selectAll: Select all visible logs
  - deleteSelected: Move selected to deleted (hide them)
  - clearSelection: Clear all selections
  - clearDeleted: Restore all hidden logs
  - toggleWrap: Toggle text wrapping for a log entry
  - cleanupInvalidHashes: Remove stale hashes when loading new file
- Added custom selectionStorage for Set serialization/deserialization
- Added localStorage persistence (only deletedHashes and wrappedHashes persist - selections reset on load)
- Updated App.tsx with Selection Test section:
  - Stats display (Selected, Deleted, Wrapped counts)
  - Action buttons (Select All, Clear Selection, Delete Selected, Restore Deleted)
  - Log entries with selection checkboxes and wrap toggle buttons
  - Click to select, Shift+Click for range, Ctrl/Cmd+Click to add
- Verified with Playwright:
  - Single selection works (click log entry, selected count = 1)
  - Select All works (43 logs selected)
  - Delete Selected works (43 deleted, 0 visible)
  - Restore Deleted works (all 43 visible again)
  - Wrap toggle works (expand/collapse text button)

### Files modified:
- ui/src/store.ts (added useSelectionStore and selectionStorage)
- ui/src/App.tsx (added Selection Test section with interactive UI)
- prd.json (marked frontend-store-selection as complete)

### Notes for next developer:
- Import selection store: `import { useSelectionStore } from './store'`
- Store hook usage: `const { selectedHashes, toggleSelection, selectAll, ... } = useSelectionStore()`
- Use filterLogs with deletedHashes to hide deleted logs: `filterLogs(logs, filters, inactiveNames, deletedHashes)`
- localStorage key: "mocha-selection-state"
- Next task should be frontend-store-file for file state management
- After all stores are complete, proceed to UI components (ui-sidebar, ui-toolbar, ui-logline, ui-logviewer)

## 2026-01-12 - frontend-store-file COMPLETED

### What was done:
- Added useFileStore to ui/src/store.ts for file and loading state management
- Implemented all required state and actions:
  - currentFile: OpenedFile | null for currently opened file info
  - recentFiles: RecentFile[] for array of recently opened files
  - isLoading: boolean for loading indicator
  - error: string | null for error messages from file operations
  - setCurrentFile: Sets current file and clears error
  - setRecentFiles: Updates recent files array
  - setLoading: Sets loading state
  - setError: Sets error and clears loading state
- Added localStorage persistence for recentFiles only (using zustand/persist)
- Updated App.tsx with File Store Test section:
  - Current file info display (name, path, size)
  - Status indicator (loading spinner or idle)
  - Error display with alert icon
  - Recent files list (clickable to re-select)
  - Action buttons: Simulate File Load, Simulate Error, Clear Current File, Clear Recent
- Verified with Playwright:
  - Simulate File Load works (sets current file, adds to recent files, shows loading state)
  - Simulate Error works (displays error message)
  - Clear Current File works (clears file and error)
  - Clicking recent file sets it as current
  - Clear Recent works (empties recent files list)

### Files modified:
- ui/src/store.ts (added useFileStore with persistence)
- ui/src/App.tsx (added File Store Test section with interactive UI)
- prd.json (marked frontend-store-file as complete)

### Notes for next developer:
- Import file store: `import { useFileStore } from './store'`
- Store hook usage: `const { currentFile, recentFiles, isLoading, error, setCurrentFile, ... } = useFileStore()`
- localStorage key: "mocha-file-state"
- ALL THREE ZUSTAND STORES ARE NOW COMPLETE (useLogViewerStore, useSelectionStore, useFileStore)
- Next tasks should be UI components: ui-sidebar, ui-toolbar, ui-logline, ui-logviewer
- Or backend tasks: backend-readfile, backend-json-escape, backend-recent-get, backend-recent-add

## 2026-01-12 - ui-logline COMPLETED

### What was done:
- Created ui/src/components/LogLine.tsx - the core log entry display component
- Implemented all required features per spec:
  - Selection gutter on left (checkbox appears when selected)
  - Timestamp column (extracts time from parsed timestamp)
  - Service badge with color coding (matches service names to colors)
  - Level badge with styling (ERROR=red, WARN=amber, INFO=blue, DEBUG=gray)
  - Log content with truncation (line-clamp-3 when not wrapped)
  - Click anywhere to toggle selection
  - Content click toggles text wrapping
  - Wrap toggle button on right
- Added level-based row styling (ERROR lines have red background, etc.)
- Created components/index.ts for clean exports
- Updated App.tsx to use LogLine component instead of inline rendering
- Fixed bug in store.ts: selectionStorage merge function wasn't converting arrays back to Sets on load
- Verified with Playwright:
  - Log entries render with service badge, content, wrap button
  - Clicking on log entry toggles selection (selected count updates)
  - Clicking on content toggles wrap (wrapped count updates)
  - Visual indicators work (checkmark in gutter, button states)

### Files created:
- ui/src/components/LogLine.tsx
- ui/src/components/index.ts

### Files modified:
- ui/src/App.tsx (imports and uses LogLine component)
- ui/src/store.ts (fixed selectionStorage merge function for Set hydration)
- prd.json (marked ui-logline as complete)

### Notes for next developer:
- Import LogLine: `import { LogLine } from './components'`
- Props: `{ log, isSelected, isWrapped, onSelect, onToggleWrap }`
- Component is memoized for performance
- Service colors are defined in SERVICE_COLORS constant - add new services there
- The component expects light theme styling - will need adjustment if app uses dark theme
- Next tasks should be: ui-sidebar, ui-toolbar, ui-logviewer, or ui-dropzone
- Consider ui-logviewer next as it will use LogLine and add keyboard shortcuts

## 2026-01-12 - ui-logviewer COMPLETED

### What was done:
- Created ui/src/components/LogViewer.tsx - the main log display component
- Implemented all required features per spec:
  - Applies service filter (inactiveNames) from useLogViewerStore
  - Applies text/regex filters from useLogViewerStore
  - Excludes deleted hashes from useSelectionStore
  - Reverses logs for newest-first display
  - Renders LogLine for each visible log entry
  - Keyboard shortcuts:
    - Ctrl+A: Select all visible logs
    - Ctrl+C: Copy selected logs to clipboard
    - Delete/Backspace: Hide selected logs (move to deleted)
    - Escape: Clear selection
  - Clipboard copy extracts raw log data in display order
  - Empty state messages for no logs loaded or no matches
- Updated components/index.ts to export LogViewer
- Updated App.tsx to use LogViewer component instead of inline LogLine rendering
- Cleaned up unused imports/variables in App.tsx (removed handleLogClick, toggleWrap, etc.)
- Verified with Playwright:
  - File upload loads 27 log entries
  - Ctrl+A selects all 27 entries (verified by selected count)
  - Delete key hides all selected (27 deleted, 0 visible)
  - Restore Deleted button restores all hidden logs
  - Wrap toggle works (Wrapped count updates)
  - Service badges and timestamps display correctly

### Files created:
- ui/src/components/LogViewer.tsx

### Files modified:
- ui/src/components/index.ts (added LogViewer export)
- ui/src/App.tsx (uses LogViewer, cleaned up unused code)
- prd.json (marked ui-logviewer as complete)

### Notes for next developer:
- Import LogViewer: `import { LogViewer } from './components'`
- Props: `{ logs: LogEntry[] }` - just pass the parsed logs array
- LogViewer uses Zustand stores internally for filters/selection state
- Keyboard shortcuts are global (document-level) but only fire when not in input fields
- The component reverses logs automatically for newest-first display
- Empty states show helpful messages for "no logs" vs "no matches"
- Next tasks should be: ui-sidebar, ui-toolbar, or ui-dropzone
- Integration tasks can start once Sidebar/Toolbar are ready

## 2026-01-12 - ui-sidebar COMPLETED

### What was done:
- Created ui/src/components/Sidebar.tsx - file navigation sidebar component
- Implemented all required features per spec:
  - "Open File..." button at top that triggers file input
  - Recent files list with file icon, name, and relative timestamp
  - Active indicator (blue highlight) for currently open file
  - Clear button (trash icon) to remove all recent files
  - Click on recent file to re-open it
  - Footer showing file count
- Added formatRelativeTime() helper function for human-readable timestamps
  - Displays "Just now", "X mins ago", "X hours ago", "X days ago"
- Updated components/index.ts to export Sidebar
- Integrated Sidebar into App.tsx layout:
  - Added flex container with sidebar on left
  - Added handleSelectFile() to open files or trigger file input
  - Added handleClearRecent() to clear recent files list
- Verified with Playwright:
  - "Open File..." button triggers file chooser dialog
  - File upload works and logs display correctly
  - "Simulate File Load" button adds file to sidebar
  - Recent file displays with name and "Just now" timestamp
  - Clear button removes all recent files
  - Sidebar layout appears correctly (light gray bg, 256px width)

### Files created:
- ui/src/components/Sidebar.tsx

### Files modified:
- ui/src/components/index.ts (added Sidebar export)
- ui/src/App.tsx (integrated Sidebar into layout)
- prd.json (marked ui-sidebar as complete)

### Notes for next developer:
- Import Sidebar: `import { Sidebar } from './components'`
- Props: `{ recentFiles, currentFile, onSelectFile, onClearRecent }`
- onSelectFile(path?) - if path provided, re-open that file; if undefined, trigger file dialog
- formatRelativeTime() converts timestamps to human-readable strings
- Sidebar uses light theme (bg-gray-50) while main content uses dark theme
- Next tasks should be: ui-toolbar, ui-dropzone, ui-fileinput, or ui-app
- Once Toolbar is done, can integrate all components into final App layout

## 2026-01-12 - ui-toolbar COMPLETED

### What was done:
- Created ui/src/components/Toolbar.tsx - toolbar for filtering and file controls
- Implemented all required features per spec:
  - File info display (name, line count, truncation indicator)
  - Service badges (clickable to toggle visibility, color-coded)
  - Active filter chips (removable with X button)
  - Filter input with Enter to add filter
  - Support for /regex/ syntax detection
  - Support for -exclude prefix detection
  - Watch/polling toggle button with Eye/EyeOff icons
- Added ExtendedToolbarProps interface for additional display props (totalLines, truncated, visibleCount, isWatching)
- Integrated Toolbar into App.tsx layout between Sidebar and main content
- Added isWatching state and handleToggleWatch handler in App.tsx
- Fixed JSX structure issue (missing closing div tag)
- Verified with Playwright:
  - File loads correctly (27 log entries)
  - Service badge appears in toolbar
  - Filter input accepts "ERROR", creates filter chip, reduces visible logs to 3
  - Filter chip X button removes filter, logs return to 27
  - Watch toggle button switches between enable/disable states

### Files created:
- ui/src/components/Toolbar.tsx

### Files modified:
- ui/src/components/index.ts (added Toolbar export)
- ui/src/App.tsx (integrated Toolbar, added isWatching state, fixed JSX structure)
- prd.json (marked ui-toolbar as complete)

### Notes for next developer:
- Import Toolbar: `import { Toolbar } from './components'`
- Props: ToolbarProps (from types.ts) + extended props: totalLines, truncated, visibleCount, isWatching
- Filter input parses text into ParsedFilter with type detection (regex, exclude, text)
- SERVICE_COLORS in Toolbar.tsx defines badge colors for known services
- Toolbar uses white background (bg-white) to contrast with dark main content
- Next tasks should be: ui-dropzone, ui-fileinput, or ui-app for full integration
- Consider backend tasks: backend-readfile, backend-json-escape, backend-recent-get, backend-recent-add

## 2026-01-12 - ui-dropzone COMPLETED

### What was done:
- Created ui/src/components/DropZone.tsx - drag-and-drop file loading component
- Implemented all required features per spec:
  - Invisible in normal state (renders children directly)
  - Shows blue dashed border overlay when dragging files over the dropzone
  - Overlay displays "Drop log file here" with "Accepts .log and .txt files" message
  - Validates file extensions (.log and .txt only)
  - Reads file content with FileReader
  - Calls onFileDrop callback with content and filename
  - Shows error message for invalid file types (auto-dismisses after 3s)
  - Hides overlay after drop
- Added DropZone export to components/index.ts
- Integrated DropZone into App.tsx:
  - Wraps the main scrollable content area
  - handleFileDrop function parses file and updates all stores (parse result, current file, recent files)
- Verified with Playwright:
  - File upload via Upload button works (43 log entries loaded from genie.log)
  - Drag overlay appears when simulating dragover event
  - Overlay shows correct message and styling

### Files created:
- ui/src/components/DropZone.tsx

### Files modified:
- ui/src/components/index.ts (added DropZone export)
- ui/src/App.tsx (integrated DropZone, added handleFileDrop function)
- prd.json (marked ui-dropzone as complete)

### Notes for next developer:
- Import DropZone: `import { DropZone } from './components'`
- Props: `{ onFileDrop: (content: string, fileName: string) => void, children: React.ReactNode }`
- DropZone wraps content and handles all drag events
- The overlay is absolute positioned with z-50 for proper stacking
- Error messages auto-dismiss after 3 seconds
- Next tasks should be: ui-fileinput (partially done - file input exists), ui-app (main app integration)
- Or proceed with integration tasks: int-recent-load, int-recent-add, int-recent-reopen

## 2026-01-12 - ui-app COMPLETED

### What was done:
- Completely rewrote ui/src/App.tsx to be a clean, production-ready root component
- Removed all test/debug UI sections (Setup Status, Dependencies Test, WebUI Integration Test, Store Test, Selection Test, File Store Test, Log Parser Test)
- Implemented proper layout per spec: Sidebar + MainContent (Toolbar + LogViewer)
- Added recent files loading on mount via getRecentFiles() API call
- Implemented file opening from three sources:
  1. Browser file input (hidden input, triggered by "Open File" button)
  2. Drag and drop (via DropZone component)
  3. Recent files list (via WebUI readFile binding when available)
- Added file polling support for live file updates (3 second interval)
- Implemented empty state with helpful instructions and "Open File" button
- Added error display banner with dismiss button
- Added loading indicator banner
- Proper TypeScript typing with null-safe optional chaining
- All state properly managed via Zustand stores (useLogViewerStore, useSelectionStore, useFileStore)
- Cleanup of stale selection hashes when new file is loaded

### Verified with Playwright:
- App loads with empty state showing "No log file open" message
- "Open File" button triggers file chooser dialog
- File upload loads and parses log file correctly (43 entries from genie.log)
- Recent files list populated with uploaded file
- Line count displayed in toolbar (43/44 lines)
- Filter input works: Added "INFO" filter, reduced to 30 logs
- Filter chip appears and can be removed with X button
- Ctrl+A selects all logs (checkmark icons appear)
- Escape clears selection (checkmark icons disappear)
- Sidebar shows recent file with "Just now" timestamp
- Clear recent files button visible

### Files modified:
- ui/src/App.tsx (complete rewrite - clean production UI)
- prd.json (marked ui-app as complete)

### Notes for next developer:
- The App component is now clean and production-ready
- All test UI has been removed - use npm run dev and interact directly
- File opening works in browser mode (file input/drop) and WebUI mode (recent files via readFile)
- Polling only works in WebUI mode when a file is opened by path
- Next priority tasks should be backend tasks that have empty passes:
  - backend-readfile: Already mostly implemented, verify it works correctly
  - backend-json-escape: Already implemented in setup-webui
  - backend-recent-get: Already implemented in setup-webui
  - backend-recent-add: Already implemented in setup-webui
- Or integration tasks: int-recent-load, int-recent-add, int-recent-reopen, int-polling, int-hash
- Polish tasks can be done after core functionality is complete
